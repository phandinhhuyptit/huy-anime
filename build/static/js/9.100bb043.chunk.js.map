{"version":3,"sources":["skeletons/AnimeCardSkeleton.tsx","components/AnimeCard.tsx","hooks/useQueryParams.ts","../../src/useIntersectionObserver.ts","../../src/useTrackVisibility.ts","../../src/useInfiniteScroll.ts","pages/SearchScreen/index.tsx","hooks/useDebounce.ts"],"names":["AnimeCardSkeleton","props","className","classNames","AnimeCard","to","slug","src","thumbnail","alt","name","size","time","latestEpisode","useQueryParams","location","useLocation","URLSearchParams","search","DEFAULT_THRESHOLD","useTrackVisibility","rootMargin","args","threshold","nodeRef","useRef","rootRef","observerRef","useState","entry","setEntry","unobserve","useCallback","currentObserver","useEffect","observe","node","root","observer","IntersectionObserver","newEntry","initializeObserver","useIntersectionObserver","ref","result","isVisible","Boolean","wasEverVisible","setWasEverVisible","loading","hasNextPage","onLoadMore","disabled","delayInMs","DEFAULT_DELAY_IN_MS","shouldLoadMore","timer","setTimeout","clearTimeout","SearchScreen","query","navigate","useNavigate","get","keyword","setKeyword","debouncedKeyword","value","delay","React","debouncedValue","setDebouncedValue","handler","useDebounce","useSearch","limit","enabled","data","isLoading","fetchNextPage","isFetchingNextPage","useInfiniteScroll","sentryRef","list","pages","map","flat","Input","type","placeholder","onChange","e","target","replace","Skeleton","Array","fill","_","i","length","anime","Loader"],"mappings":"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","file":"static/js/9.100bb043.chunk.js","sourcesContent":["import classNames from \"classnames\";\nimport React from \"react\";\n\ninterface AnimeCardSkeletonProps {\n  className?: string;\n}\n\nconst AnimeCardSkeleton = (props: AnimeCardSkeletonProps) => {\n  return (\n    <div className={classNames(\"-space-x-2 px-2\", props.className)}>\n      <div className=\"w-full h-32\">\n        <div className=\"bg-gray-600 w-full h-full\"></div>\n      </div>\n    </div>\n  );\n};\n\nexport default AnimeCardSkeleton;\n","import classNames from \"classnames\";\nimport React from \"react\";\nimport { AiFillPlayCircle } from \"react-icons/ai\";\nimport { Link } from \"react-router-dom\";\nimport { Anime } from \"../types\";\nimport Image from \"./Image\";\n\ninterface AnimeCardProps extends Anime {\n  className?: string;\n}\n\nconst AnimeCard = (props: AnimeCardProps) => {\n  return (\n    <Link to={`/info/${props.slug}`}>\n      <div className={classNames(\"relative shadow-lg group\", props.className)}>\n        <Image\n          src={props.thumbnail}\n          alt={props.name}\n          className={classNames(\n            \"w-full h-32 object-cover rounded-md rounded-b-none\"\n          )}\n        />\n\n        <div className=\"absolute inset-0 invisible group-hover:visible bg-black bg-opacity-60 flex items-center justify-center\">\n          <AiFillPlayCircle size={50} className=\"text-white\" />\n        </div>\n\n        <div className=\"px-2 py-1 absolute top-2 left-2 max-w-24 bg-black rounded-md bg-opacity-80\">\n          <p className=\"text-white text-xs line-clamp-1\">\n            {props.time || props.latestEpisode?.name}\n          </p>\n        </div>\n      </div>\n      <div\n        className={classNames(\n          \"bg-background-darker p-3 w-full space-y-2 rounded-b-md min-h-4\"\n        )}\n      >\n        <p className=\"uppercase text-white font-medium text-sm line-clamp-2\">\n          {props.name}\n        </p>\n      </div>\n    </Link>\n  );\n};\n\nexport default AnimeCard;\n","import { useLocation } from \"react-router\";\n\nconst useQueryParams = () => {\n  const location = useLocation();\n\n  const params = new URLSearchParams(location.search);\n\n  return params;\n};\n\nexport default useQueryParams;\n","import { useState, useCallback, useEffect, useRef } from 'react';\r\n\r\nconst DEFAULT_ROOT_MARGIN = '0px';\r\nconst DEFAULT_THRESHOLD = [0];\r\n\r\n// eslint-disable-next-line no-undef\r\nexport type IntersectionObserverHookArgs = IntersectionObserverInit;\r\n\r\nexport type IntersectionObserverHookRefCallbackNode = Element | null;\r\n\r\nexport type IntersectionObserverHookRefCallback = (\r\n  node: IntersectionObserverHookRefCallbackNode,\r\n) => void;\r\n\r\nexport type IntersectionObserverHookRootRefCallbackNode = IntersectionObserverHookArgs['root'];\r\n\r\nexport type IntersectionObserverHookRootRefCallback = (\r\n  node: IntersectionObserverHookRootRefCallbackNode,\r\n) => void;\r\n\r\nexport type IntersectionObserverHookResult = [\r\n  IntersectionObserverHookRefCallback,\r\n  {\r\n    entry: IntersectionObserverEntry | undefined;\r\n    rootRef: IntersectionObserverHookRootRefCallback;\r\n  },\r\n];\r\n\r\n// For more info:\r\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\r\nfunction useIntersectionObserver(\r\n  args?: IntersectionObserverHookArgs,\r\n): IntersectionObserverHookResult {\r\n  const rootMargin = args?.rootMargin ?? DEFAULT_ROOT_MARGIN;\r\n  const threshold = args?.threshold ?? DEFAULT_THRESHOLD;\r\n\r\n  const nodeRef = useRef<IntersectionObserverHookRefCallbackNode>(null);\r\n  const rootRef = useRef<IntersectionObserverHookRootRefCallbackNode>(null);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n\r\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\r\n\r\n  const unobserve = useCallback(() => {\r\n    // Disconnect the current observer (if there is one)\r\n    const currentObserver = observerRef.current;\r\n    currentObserver?.disconnect();\r\n    observerRef.current = null;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      // We disconnect the observer on unmount to prevent memory leaks etc.\r\n      unobserve();\r\n    };\r\n  }, [unobserve]);\r\n\r\n  const observe = useCallback(() => {\r\n    const node = nodeRef.current;\r\n    if (node) {\r\n      const root = rootRef.current;\r\n      const options = { root, rootMargin, threshold };\r\n      // Create a observer for current \"node\" with given options.\r\n      const observer = new IntersectionObserver(([newEntry]) => {\r\n        setEntry(newEntry);\r\n      }, options);\r\n      observer.observe(node);\r\n      observerRef.current = observer;\r\n    }\r\n  }, [rootMargin, threshold]);\r\n\r\n  const initializeObserver = useCallback(() => {\r\n    unobserve();\r\n    observe();\r\n  }, [observe, unobserve]);\r\n\r\n  const refCallback = useCallback<IntersectionObserverHookRefCallback>(\r\n    (node) => {\r\n      nodeRef.current = node;\r\n      initializeObserver();\r\n    },\r\n    [initializeObserver],\r\n  );\r\n\r\n  const rootRefCallback = useCallback<IntersectionObserverHookRootRefCallback>(\r\n    (rootNode) => {\r\n      rootRef.current = rootNode;\r\n      initializeObserver();\r\n    },\r\n    [initializeObserver],\r\n  );\r\n\r\n  return [refCallback, { entry, rootRef: rootRefCallback }];\r\n}\r\n\r\nexport default useIntersectionObserver;\r\n","import { useEffect, useState } from 'react';\r\nimport useIntersectionObserver, {\r\n  IntersectionObserverHookArgs,\r\n  IntersectionObserverHookResult,\r\n} from './useIntersectionObserver';\r\n\r\nexport type TrackVisibilityHookArgs = IntersectionObserverHookArgs;\r\n\r\nexport type TrackVisibilityHookResult = [\r\n  IntersectionObserverHookResult[0],\r\n  IntersectionObserverHookResult[1] & {\r\n    isVisible: boolean;\r\n    wasEverVisible: boolean;\r\n  },\r\n];\r\n\r\nfunction useTrackVisibility(\r\n  args?: IntersectionObserverHookArgs,\r\n): TrackVisibilityHookResult {\r\n  const [ref, result] = useIntersectionObserver(args);\r\n  const isVisible = Boolean(result.entry?.isIntersecting);\r\n  const [wasEverVisible, setWasEverVisible] = useState(isVisible);\r\n\r\n  useEffect(() => {\r\n    if (isVisible) {\r\n      setWasEverVisible(isVisible);\r\n    }\r\n  }, [isVisible]);\r\n\r\n  return [ref, { ...result, isVisible, wasEverVisible }];\r\n}\r\n\r\nexport default useTrackVisibility;\r\n","import { useEffect } from 'react';\r\nimport {\r\n  useTrackVisibility,\r\n  IntersectionObserverHookArgs,\r\n  IntersectionObserverHookRefCallback,\r\n  IntersectionObserverHookRootRefCallback,\r\n} from 'react-intersection-observer-hook';\r\n\r\nconst DEFAULT_DELAY_IN_MS = 100;\r\n\r\nexport type UseInfiniteScrollHookResult = [\r\n  IntersectionObserverHookRefCallback,\r\n  { rootRef: IntersectionObserverHookRootRefCallback },\r\n];\r\n\r\nexport type UseInfiniteScrollHookArgs = Pick<\r\n  IntersectionObserverHookArgs,\r\n  // We pass this to 'IntersectionObserver'. We can use it to configure when to trigger 'onLoadMore'.\r\n  'rootMargin'\r\n> & {\r\n  // Some sort of \"is fetching\" info of the request.\r\n  loading: boolean;\r\n  // If the list has more items to load.\r\n  hasNextPage: boolean;\r\n  // The callback function to execute when the 'onLoadMore' is triggered.\r\n  // eslint-disable-next-line no-undef\r\n  onLoadMore: VoidFunction;\r\n  // Flag to stop infinite scrolling. Can be used in case of an error etc too.\r\n  disabled?: boolean;\r\n  // How long it should wait before triggering 'onLoadMore'.\r\n  delayInMs?: number;\r\n};\r\n\r\nfunction useInfiniteScroll({\r\n  loading,\r\n  hasNextPage,\r\n  onLoadMore,\r\n  rootMargin,\r\n  disabled,\r\n  delayInMs = DEFAULT_DELAY_IN_MS,\r\n}: UseInfiniteScrollHookArgs): UseInfiniteScrollHookResult {\r\n  const [ref, { rootRef, isVisible }] = useTrackVisibility({\r\n    rootMargin,\r\n  });\r\n\r\n  const shouldLoadMore = !disabled && !loading && isVisible && hasNextPage;\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  useEffect(() => {\r\n    if (shouldLoadMore) {\r\n      // When we trigger 'onLoadMore' and new items are added to the list,\r\n      // right before they become rendered on the screen, 'loading' becomes false\r\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\r\n      // So, it triggers 'onLoadMore' just after the first one is finished.\r\n      // We use a small delay here to prevent this kind of situations.\r\n      // It can be configured by hook args.\r\n      const timer = setTimeout(() => {\r\n        onLoadMore();\r\n      }, delayInMs);\r\n      return () => {\r\n        clearTimeout(timer);\r\n      };\r\n    }\r\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\r\n\r\n  return [ref, { rootRef }];\r\n}\r\n\r\nexport default useInfiniteScroll;\r\n","import React, { useState } from \"react\";\nimport useInfiniteScroll from \"react-infinite-scroll-hook\";\nimport { useNavigate } from \"react-router\";\nimport AnimeCard from \"../../components/AnimeCard\";\nimport Input from \"../../components/Input\";\nimport Loader from \"../../components/Loader\";\nimport Skeleton from \"../../components/Skeleton\";\nimport useDebounce from \"../../hooks/useDebounce\";\nimport useQueryParams from \"../../hooks/useQueryParams\";\nimport useSearch from \"../../hooks/useSearch\";\nimport AnimeCardSkeleton from \"../../skeletons/AnimeCardSkeleton\";\n\nconst SearchScreen = () => {\n  const query = useQueryParams();\n  const navigate = useNavigate();\n  const [keyword, setKeyword] = useState(query.get(\"q\"));\n  const debouncedKeyword = useDebounce(keyword || \"\", 1000);\n\n  const { data, hasNextPage, isLoading, fetchNextPage, isFetchingNextPage } =\n    useSearch({ keyword: debouncedKeyword, limit: 30, enabled: true });\n\n  const [sentryRef] = useInfiniteScroll({\n    loading: isFetchingNextPage,\n    hasNextPage: !!hasNextPage,\n    onLoadMore: fetchNextPage,\n    rootMargin: \"0px 0px 100px 0px\",\n  });\n\n  const handleKeywordChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setKeyword(e.target.value);\n    navigate(`/search?q=${e.target.value}`, { replace: true });\n  };\n\n  const list = data?.pages.map((list) => list.data).flat();\n\n  return (\n    <div className=\"px-2 py-20 lg:px-20 lg:py-24 w-full\">\n      <div className=\"w-full p-2\">\n        <div className=\"flex flex-col space-y-2 md:flex-row md:space-y-0 items-center justify-between\">\n          <p className=\"text-white font-medum text-4xl\">\n            Kết quả tìm kiếm: <strong>{keyword}</strong>\n          </p>\n\n          <Input\n            type=\"text\"\n            placeholder=\"Tìm kiếm\"\n            onChange={handleKeywordChange}\n            className=\"bg-background-darker px-3 py-2\"\n            value={keyword || \"\"}\n          />\n        </div>\n\n        {isLoading && (\n          <Skeleton className=\"my-12 flex flex-wrap\">\n            {new Array(18).fill(null).map((_, i) => (\n              <AnimeCardSkeleton\n                key={i}\n                className=\"mt-2 w-1/2 sm:w-1/3 md:w-1/4 lg:w-1/5 xl:w-1/6 2xl:w-1/7\"\n              />\n            ))}\n          </Skeleton>\n        )}\n\n        {!list?.length && (\n          <div className=\"my-12 flex items-center justify-center\">\n            <p className=\"text-gray-300 text-lg text-center\">\n              {!debouncedKeyword ? \"Nhập từ khóa\" : \"Không có\"}\n            </p>\n          </div>\n        )}\n\n        <div className=\"my-12 flex flex-wrap\">\n          {!isLoading &&\n            list?.map((anime) => (\n              <div\n                className=\"mt-2 -mr-2 px-2 w-1/2 sm:w-1/3 md:w-1/4 lg:w-1/5 xl:w-1/6 2xl:w-1/7\"\n                key={anime.slug}\n              >\n                <AnimeCard {...anime} />\n              </div>\n            ))}\n        </div>\n\n        {(isFetchingNextPage || hasNextPage) && (\n          <div ref={sentryRef}>\n            <Loader />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default SearchScreen;\n","import React from \"react\";\n\nexport default function useDebounce(value: string, delay: number = 500) {\n  const [debouncedValue, setDebouncedValue] = React.useState(value);\n\n  React.useEffect(() => {\n    const handler: NodeJS.Timeout = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Cancel the timeout if value changes (also on delay change or unmount)\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n"],"sourceRoot":""}